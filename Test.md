경계값 테스트를 하는 것이 중요하다.
테스트하기 어려운 영역을 구분하고 분리하기 -> 외부로 분리할수록 테스트 가능한 코드는 많아진다.
테스트하기 어려운 영역
- 관측할 때마다 다른 값에 의존하는 코드: 현재 날짜/시간, 랜던 값, 전역 변수/함수, 사용자 입력 등
- 외부 세계에 영향을 주는 코드: 표준 출력, 메시지 발송, 데이터베이스에 기록하기 등
순수함수가 테스트하기 좋다.
- 같은 입력에는 항상 같은 결과
- 외부 세상과 단절된 형태
- 테스트하기 쉬운 코드

테스트는 '문서'다.
- 프로덕션 기능을 설명하는 테스트 코드 문서
- 다양한 테스트 케이스를 통해 프로덕션 코드를 이해하는 시각과 관점을 보완
- 어느 한 사람이 과거에 경험했던 고민의 결과물을 팀 차원으로 승격시켜서, 모두의 자산으로 공유할 수 있다.

1. DisplayName 섬세하게 작성하자.
- 음료를 1개 추가하면 주문 목록에 담긴다.
  - 테스트 행위에 대한 결과까지 기술하기
- 영업 시작 시간 이전에는 주문을 생성할 수 없다.
  - 도메인 용어를 사용하여 한층 추상화된 내용을 담기 -> 메서드 자체의 관점보다 도메인 정책 관점으로
  - 테스트의 현상을 중점으로 기술하지 말 것 (성공한다, 실패한다라는 표현은 피하자)

2. BDD (Behavior Driven Development)
- TDD 에서 파생된 개발 방법
- 함수 단위의 테스트에 집중하기보다, 시나리오에 기반한 테스트 케이스(TC) 자체에 집중하여 테스트한다.
- 개발자가 아닌 사람이 봐도 이해할 수 있을 정도의 추상화 수준(레벨)을 권장
- Given / When / Then
  - Given: 시나리오 진행에 필요한 모든 준비 과정 (객체, 값, 상태 등)
  - When: 시나리오 행동 진행
  - Then: 시나리오 진행에 대한 결과 명시, 검증
  - 어떤 환경에서, 어떤 행동을 진행했을 때, 어떤 상태 변화가 일어난다.
    - DisplayName 명확하게 작성이 가능하다.

3. Layered Architecture
- 관심사의 분리
- Presentation, Business, Persistence Layer
  - Persistence Layer
    - Data Access의 역할
    - 비즈니스 가공 로직이 포함되어서는 안된다.
    - Data에 대한 CRUD에만 집중한다.
  - 비즈니스 로직을 구현하는 역할
    - Persistence Layer와의 상호작용을 통해 비즈니스 로직을 전개시킨다.
    - 트랜잭션을 보장해야 한다.

4. 통합 테스트
- 여러 모듈이 협력하는 기능을 통합적으로 검증하는 테스트
- 일반적으로 작은 범위의 단위 테스트만으로는 기능 전체의 신뢰성을 보장할 수 없다.
- 풍부한 단위 테스트 & 큰 기능 단위를 검증하는 통합 테스트